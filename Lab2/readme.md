In this repository, we implemented MapReduce. all code written by us can be found in src/main/mr. Code for the worker can be found in worker.go, code for the coordinator is found in coordinator.go.

The Worker and Coordinator communicate with each other via rpc. The Args and Reply structs are declared in rpc.go. Args is used for the worker to send information to the coordinator, Raply is used for the coordinator to send data to the worker.
If the worker coordinator completed a task, info about that task can be found in the Args struct.	This is the time the coordinator sent the task to the worker, a boolean which says what kind of task it is (map/reduce) and either the specific map or reduce task.
The fields of the Reply struct are the time the coordinator sends the task, the type of task the worker will get (Map, Reduce, Wait or Done), which map/reduce task should be handled and possibly the amount of intermediate files a map task should output.

The coordinator keeps a lot of information. For each map/reduce task that should happen, it keeps track of a state (unstarted, running and finished). Each unstarted task is also added to a specific channel. When a worker asks for a new task, the coordinator can pop a new task from this channel and it's state is modified to "running". To know what kind of task the coordinator should assign to a new worker, a state is held. This can be Map, Reduce, Wait or Done. Waiting happens when there are no unstarted tasks of the required type, but they're not finished yet. Other variables the coordinator keeps track of are the total amount of map tasks, the total amount of reduce tasks, the amount of finished map tasks, the amount of finished reduce tasks and the amount of seconds a worker has to complete a task. All variables are initialized when the coordinator is created, and all variables which change later are locked whenever necessary.

A worker keeps goint through a loop as long as it is active. It only shuts down when it can't reach the coordinator or when it receives the "Done" command. In the beginning of the loop, the worker calls the coordinator to get a task. Based on its response, it either maps, reduces, waits or shuts down.
